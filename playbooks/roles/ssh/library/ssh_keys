#!/usr/bin/python

# Copyright: (c) 2018, Terry Jones <terry.jones@example.org>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from pathlib import Path
import os, time

DOCUMENTATION = r'''
---
module: ssh_keys

short_description: manages keys in the authorized_keys file

# If this is part of a collection, you need to use semantic versioning,
# i.e. the version is of the form "2.5.0" and not "2.4".
version_added: "1.0.0"

description: This module adds and removes keys from the authorized_keys file, while maintaining idempotency
and allowing for more advanced options.

options:
    user:
        description: The user whose key file is edited
        required: true
        type: str
    key:
        description: This is the public key to add/remove.
        required: true
        type: str
    present:
        description:
            - bool to determine whether the key should exist or not
        required: true
        type: bool
    expire_time:
        description: Time in days until the key expires
        required: false
        type: int
    update_expire_time:
        description: updates the expire time if the key exists
        required: false
        type: bool
    file_path:
        description: custom path to authorized_keys file
        required: false
        type: str

# Specify this value according to your collection
# in format of namespace.collection.doc_fragment_name
extends_documentation_fragment:
    - mattjs.wirelessvt_testbed_admin.ssh_keys

author:
    - Matthew Salerno (@matthew-salerno)
'''

EXAMPLES = r'''
# Add
- name: Add key to file
  mattjs.wirelessvt_testbed_admin.ssh_keys:
    user: user
    key: ssh-rsa AAAAB3Nza...
    present: true

# Remove
- name: Remove key from file
  mattjs.wirelessvt_testbed_admin.ssh_keys:
    user: user
    key: ssh-rsa AAAAB3Nza...
    present: false

# Expiring
- name: Add key that expires in one year
  mattjs.wirelessvt_testbed_admin.ssh_keys:
    user: user
    key: ssh-rsa AAAAB3Nza...
    present: true
    expire_time: 365

- name: Add key that expires in one year, resetting the expiration if it exists
  mattjs.wirelessvt_testbed_admin.ssh_keys:
    user: user
    key: ssh-rsa AAAAB3Nza...
    present: true
    expire_time: 365
    update_expire_time: true

- name: Add key that expires in one year remove expiration if there is one
  mattjs.wirelessvt_testbed_admin.ssh_keys:
    user: user
    key: ssh-rsa AAAAB3Nza...
    present: true
    update_expire_time: true
'''

RETURN = r'''
# These are examples of possible return values, and in general should use other names for return values.
'''

'''List of valid key types for openssh'''
KEY_TYPES = {
    "ssh-ed25519-cert-v01@openssh.com",
    "ecdsa-sha2-nistp256-cert-v01@openssh.com",
    "ecdsa-sha2-nistp384-cert-v01@openssh.com",
    "ecdsa-sha2-nistp521-cert-v01@openssh.com",
    "sk-ssh-ed25519-cert-v01@openssh.com",
    "sk-ecdsa-sha2-nistp256-cert-v01@openssh.com",
    "rsa-sha2-512-cert-v01@openssh.com",
    "rsa-sha2-256-cert-v01@openssh.com",
    "ssh-rsa-cert-v01@openssh.com",
    "ssh-ed25519",
    "ecdsa-sha2-nistp256",
    "ecdsa-sha2-nistp384",
    "ecdsa-sha2-nistp521",
    "sk-ssh-ed25519@openssh.com",
    "sk-ecdsa-sha2-nistp256@openssh.com",
    "rsa-sha2-512",
    "rsa-sha2-256",
    "ssh-rsa"
    }

from ansible.module_utils.basic import AnsibleModule

def load_keys(path: Path, module: AnsibleModule) -> dict:
    '''
    loads keys from an authorized keys file
    '''
    keys = {}
    try:
        with path.open(mode='r') as key_file:
            while args := key_file.readline():
                # check for comments and empty lines
                if not args or args[0] == "#":
                    continue

                # seperate out escaped portions
                args = args.split('\"')
                is_escaped = lambda x: x%2==1
                if is_escaped(len(args)-1):
                    module.fail_json(msg='Could not parse line, missing \"', **result)
                
                # comments is wrapped in tuple to make escaping more general
                temp_entry = (dict(options=list(), key=str(), comments=[str(),]))
                state = 'options'
                for (pos, sub_line) in enumerate(args):
                    if is_escaped(pos):
                        temp_entry[state][-1] += '\"' + sub_line + '\"'
                    else: 
                        for part in sub_line.split(' '):
                            if state == 'options':
                                if part in KEY_TYPES:
                                    state = 'key'
                                    temp_entry['key'] = part+" "
                                else:
                                    temp_entry['options'].append(part)
                            elif state == 'key':
                                temp_entry['key'] += part
                                temp_entry['key'] = temp_entry['key'].strip()
                                state = 'comments'
                            elif state == 'comments':
                                temp_entry['comments'][0]+=part+" "
                # unwrap comments now
                temp_entry['comments'] = temp_entry['comments'][0]
                keys[temp_entry['key']] = {'options': temp_entry['options'], 'comments': temp_entry['comments']}
    except FileNotFoundError:
        pass
    return keys

def run_module():
    # define available arguments/parameters a user can pass to the module
    print("test")
    module_args = dict(
        user=dict(type='str', required=True),
        key=dict(type='str', required=True),
        present=dict(type='bool', required=True),
        expire_time=dict(type='int', required=False, default=0),
        update_expire_time=dict(type='bool', required=False, default=False),
        file_path=dict(type='str', required=False, default="")
    )

    # seed the result dict in the object
    # we primarily care about changed and state
    # changed is if this module effectively modified the target
    # state will include any data that you want your module to pass back
    # for consumption, for example, in a subsequent task
    result = dict(
        changed=False
    )

    # the AnsibleModule object will be our abstraction working with Ansible
    # this includes instantiation, a couple of common attr would be the
    # args/params passed to the execution, as well as if the module
    # supports check mode
    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    # set the path
    if not module.params['file_path']:
        module.params['file_path'] = f"/home/{module.params['user']}/.ssh/authorized_keys"
    working_path = Path(module.params['file_path'])
    module.params['key'] = module.params['key'].strip()
    os.chdir(working_path.parent)

    keys = load_keys(working_path, module)
    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    expire_string = f"expiry-time=\"{time.strftime(r'%Y%m%d', time.gmtime(time.time()+60*60*24*module.params['expire_time']))}\""
    if module.params['key'] in keys:
        # next line just gets index of time parameters if it exists
        expire_pos = [i for i, t in enumerate(keys[module.params['key']]['options']) if t.find('expiry-time=')!=-1]
        if not module.params['present']:
            del keys[module.params['key']]
            result['changed'] = True
        elif module.params['update_expire_time']:
            if module.params['expire_time'] == 0 and len(expire_pos) >= 0:
                for pos in expire_pos:
                    keys[module.params['key']]['options'][pos] = ""
                result['changed'] = True
            elif len(expire_pos) >= 0:
                keys[module.params['key']]['options'][expire_pos[0]] = expire_string
                result['changed'] = True
        elif module.params['expire_time'] > 0 and len(expire_pos) == 0:
            keys[module.params['key']]['options'].append(expire_string)
            result['changed'] = True
    elif module.params['present']:
        keys[module.params['key']] = dict(
            options=[expire_string],
            comments=f"{module.params['user']}"
        )
        result['changed'] = True

    # write back to file if not check mode and if there need to be changes
    if not module.check_mode and result['changed']:
        with working_path.open(mode='w') as fout:
            fout.write("# AUTO GENERATED BY ssh_keys.py VIA ANSIBLE\n")
            for (key, values) in keys.items():
                if key.strip():
                    options = values['options']
                    comments = values['comments']
                    for option in options:
                        if option: 
                            fout.write(option+' ')
                    fout.write(key+' ')
                    fout.write(comments.strip() + '\n')

    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)


def main():
    run_module()


if __name__ == '__main__':
    main()

